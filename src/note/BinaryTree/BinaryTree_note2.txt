Construct Binary Tree from Inorder and Postorder 106
根据树的中序和后序遍历序列,利用递归构建二叉树. 递归出口为if语句对变量是否小于0的判断,递归方法一进入就构建一个新节点.

construct-binary-tree-from-preorder-and-inorder-traversal 105
根据树的先序和中序遍历序列,利用递归构建二叉树


108. Convert Sorted Array to Binary Search Tree
根据一个已排好序的序列,利用递归构建平衡二叉树.
递归出口:      if (start > end) return null;
             int mid = start + (end - start) / 2;

109. Convert Sorted List to Binary Search Tree
将一个排好序的单链表,利用递归构建平衡二叉树
// scan once to point at the middle node
        while (p != null && p.next != null) {
            p = p.next.next;
            pre = pre.next;
            mid++;
        }

    // 有效地计算中间节点
  int mid = start + (end - start) / 2;
         int increment = (end - start) / 2;
         ListNode newHead = startNode;
         for (int i = 0; i < increment; i++) {
             newHead = newHead.next;
         }

114. Flatten Binary Tree to Linked List

   分析题: 详细分情况讨论
   1 root左右节点都有,结合递归求解
   2 root 有左节点无右节点
   3 root 无左节点有右节点
   4 root 既无左节点又无右节点




